The
image
illustrates
a
communication
network,
showcasing
the
intricate
exchange
of
messages
between
distinct
nodes.
It
comprises
three
horizontal
lines
denoted
as
P0,
P1,
and
P2,
each
hosting
eight
labeled
points:
A1,
B2,
C3,
D4,
E1,
F1,
G2,
and
H1.
These
points
are
interconnected
by
lines,
bearing
numerical
labels
that
likely
signify
the
message
flow.
Notably,
the
diagram
employs
black
circles
to
mark
local
events
and
arrows
to
signify
message
transmissions.
Such
visual
representations
are
commonly
employed
in
computer
science
to
provide
a
clear
visualization
of
data
propagation
within
a
network.
Here,
we
could
say
that
E
->B
as
timestamp(E)
<
timestamp(B),
and
there
is
a
causal
path
from
A
to
B.
Similarly,
C->I,
F->G
and
so
on.
But
if
we
consider
the
events,
A
and
E
we
have
a
timestamp(A)
=
timestamp(E).
But
there
is
no
causal
path
from
A
to
E
or
E
to
A.
Similarly,
for
the
events,
A
and
G,
we
have
timestamp(A)
<
timestamp(G).
But
there
is
no
causal
path
from
A
to
G
or
G
to
A.
These
events
are
called
concurrent
events
and
a
pair
of
concurrent
events
doesn’t
have
a
causal
path
from
one
event
to
another.
❖
Algorithm
1)
Initialize
a
local
logical
clock
to
0
for
each
process
in
the
distributed
system.
2)
When
an
parallel
event
occurs:
a)
clock
=
clock
+
1
3)
When
a
sequential
event
occurs
a)
Pass
timestamp
of
the
calling
server
in
request
(received_ts)
b)
clock
=
max(received_ts,
clock)
+
1